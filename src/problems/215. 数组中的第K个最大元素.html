<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top K: å †æ’åº vs å¿«é€Ÿé€‰æ‹© (ä¿®å¤ç‰ˆ)</title>
    <style>
        :root {
            --primary: #2563eb;
            --heap-color: #8b5cf6;
            --quick-color: #ec4899;
            --bg: #f1f5f9;
            --card-bg: #ffffff;
            --text-main: #1e293b;
        }

        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: var(--text-main); display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }

        /* å¸ƒå±€å®¹å™¨ */
        .main-card { background: var(--card-bg); width: 95%; max-width: 1000px; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); padding: 24px; display: flex; flex-direction: column; align-items: center; }

        /* é¡¶éƒ¨å¯¼èˆª */
        .nav-tabs { display: flex; gap: 10px; margin-bottom: 20px; background: #e2e8f0; padding: 4px; border-radius: 8px; }
        .tab-btn { padding: 8px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; color: #64748b; background: transparent; transition: all 0.2s; }
        .tab-btn.active { background: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .tab-btn.active.t-heap { color: var(--heap-color); }
        .tab-btn.active.t-quick { color: var(--quick-color); }

        /* è¾“å…¥åŒº */
        .input-group { display: flex; gap: 10px; align-items: center; margin-bottom: 20px; flex-wrap: wrap; justify-content: center; }
        input { padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; text-align: center; }
        .btn-run { background: var(--primary); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; }
        .btn-run:hover { background: #1d4ed8; }

        /* === æ ¸å¿ƒå¯è§†åŒ–èˆå° (å…³é”®ä¿®å¤ç‚¹) === */
        /* ä½¿ç”¨ relative å®šä½ï¼Œç¡®ä¿å†…éƒ¨ absolute å…ƒç´ ç›¸å¯¹äºæ­¤æ¡†å®šä½ */
        #stage-container {
            width: 800px;
            height: 400px;
            position: relative;
            background: #fafafa;
            border: 1px dashed #cbd5e1;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden; /* é˜²æ­¢æº¢å‡º */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* é€šç”¨èŠ‚ç‚¹æ ·å¼ */
        .node-base {
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 16px; background: white;
            border: 2px solid #334155; transition: transform 0.2s, background-color 0.2s;
            z-index: 10;
        }

        /* --- æ¨¡å¼ A: å † (ç»å¯¹å®šä½) --- */
        .heap-node {
            position: absolute; width: 44px; height: 44px; border-radius: 50%;
            /* x,y ç”± JS è®¾ç½® */
        }
        /* SVG è¿çº¿å±‚ï¼šå¿…é¡»è¦†ç›–æ•´ä¸ªå®¹å™¨ä¸”ä½äºèŠ‚ç‚¹ä¸‹æ–¹ */
        .lines-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none;
        }
        line { stroke: #cbd5e1; stroke-width: 2; }

        /* --- æ¨¡å¼ B: å¿«é€‰ (Flexæµå¼å¸ƒå±€) --- */
        .quick-row { display: flex; gap: 8px; align-items: flex-end; padding-bottom: 40px; }
        .quick-node {
            width: 45px; height: 45px; border-radius: 6px; position: relative;
        }
        .idx-tag { position: absolute; bottom: -20px; width: 100%; text-align: center; font-size: 10px; color: #94a3b8; }

        /* --- çŠ¶æ€é«˜äº® --- */
        .hl-compare { background: #fef3c7 !important; border-color: #d97706 !important; transform: scale(1.1); }
        .hl-swap { background: #fee2e2 !important; border-color: #ef4444 !important; transform: scale(1.15); }
        .hl-pivot { background: #fce7f3 !important; border-color: #db2777 !important; }
        .hl-sorted { background: #dcfce7 !important; border-color: #16a34a !important; color: #166534; box-shadow: 0 0 10px #86efac; }
        .hl-inactive { opacity: 0.3; border-color: #e2e8f0; }

        /* --- æŒ‡é’ˆæ ‡è®° --- */
        .ptr {
            position: absolute; font-size: 11px; font-weight: bold; color: white;
            padding: 2px 5px; border-radius: 4px; pointer-events: none; z-index: 20;
            white-space: nowrap; transition: all 0.2s;
        }
        .ptr-i { background: #ef4444; }
        .ptr-j { background: #3b82f6; }
        .ptr-p { background: #db2777; bottom: -28px; }

        /* åº•éƒ¨æ§åˆ¶ */
        .controls-btm { width: 100%; display: flex; gap: 15px; align-items: center; justify-content: center; background: #f8fafc; padding: 15px; border-radius: 8px; }
        input[type=range] { flex-grow: 1; max-width: 300px; accent-color: var(--primary); }
        .log-box { width: 100%; height: 50px; margin-top: 10px; font-family: monospace; font-size: 13px; color: #475569; text-align: center; line-height: 50px; background: #f1f5f9; border-radius: 6px; }

        /* è¡¨æ ¼åŒºåŸŸ */
        .table-section { margin-top: 30px; width: 100%; }
        table { width: 100%; border-collapse: collapse; font-size: 14px; }
        th, td { border: 1px solid #e2e8f0; padding: 12px; text-align: left; }
        th { background: #f8fafc; color: #64748b; }
        .tag { padding: 2px 6px; border-radius: 4px; font-size: 12px; font-weight: bold; }
        .tag-good { background: #dcfce7; color: #166534; }
        .tag-bad { background: #fee2e2; color: #991b1b; }
        .tag-mid { background: #fef9c3; color: #854d0e; }

    </style>
</head>
<body>

<div onclick="window.opener?window.close():window.history.back()" style="position:fixed;top:15px;left:15px;cursor:pointer;background:white;padding:8px 12px;border-radius:8px;border:1px solid #e2e8f0;box-shadow:0 2px 8px rgba(0,0,0,0.1);z-index:99;">ğŸ”™ è¿”å›</div>

<div class="main-card">
    <h2>æ•°ç»„ä¸­çš„ç¬¬ K ä¸ªæœ€å¤§å…ƒç´ </h2>

    <div class="nav-tabs">
        <button class="tab-btn active t-heap" onclick="switchMode('heap')">âš¡ å †æ’åº (Heap)</button>
        <button class="tab-btn t-quick" onclick="switchMode('quick')">ğŸš€ å¿«é€Ÿé€‰æ‹© (Quick Select)</button>
    </div>

    <div class="input-group">
        <label>æ•°ç»„: <input type="text" id="arrIn" value="3, 2, 1, 5, 6, 4" style="width:200px"></label>
        <label>K: <input type="number" id="kIn" value="2" style="width:50px" min="1"></label>
        <button class="btn-run" onclick="init()">ğŸ”„ ç”Ÿæˆæ¼”ç¤º</button>
    </div>

    <div id="stage-container">
    </div>

    <div class="controls-btm">
        <button class="btn-run" style="background:white; color:#333; border:1px solid #ccc" onclick="step(-1)">â®</button>
        <button class="btn-run" id="playBtn" onclick="togglePlay()">â¯</button>
        <button class="btn-run" style="background:white; color:#333; border:1px solid #ccc" onclick="step(1)">â­</button>
        <input type="range" id="progressBar" min="0" value="0" oninput="seek(this.value)">
        <span id="stepTxt" style="font-family:monospace; width:60px">0/0</span>
        <select id="speedSel">
            <option value="800">æ…¢</option>
            <option value="400" selected>ä¸­</option>
            <option value="100">å¿«</option>
        </select>
    </div>
    <div class="log-box" id="logTxt">å‡†å¤‡å°±ç»ª...</div>

    <div class="table-section">
        <h3>ğŸ“Š ç®—æ³•æ ¸å¿ƒå¯¹æ¯”</h3>
        <table>
            <thead>
            <tr>
                <th width="15%">ç»´åº¦</th>
                <th width="42%">Max Heap (å †æ’åºæ€è·¯)</th>
                <th width="43%">Quick Select (å¿«é€Ÿé€‰æ‹©)</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>æ—¶é—´å¤æ‚åº¦</strong></td>
                <td>
                    <span class="tag tag-mid">O(N + K log N)</span><br>
                    <small>å»ºå † O(N)ï¼Œå¼¹å‡º K æ¬¡æ¯æ¬¡ O(log N)</small>
                </td>
                <td>
                    <span class="tag tag-good">O(N)</span> (æœŸæœ›)<br>
                    <small>æ¯æ¬¡æ’é™¤ä¸€åŠåŒºåŸŸï¼Œå‘ˆæ”¶æ•›çº§æ•°</small>
                </td>
            </tr>
            <tr>
                <td><strong>æœ€åæƒ…å†µ</strong></td>
                <td>ç¨³å®š O(N log N)</td>
                <td><span class="tag tag-bad">O(NÂ²)</span> (å¦‚æœ Pivot é€‰å¾—å¾ˆå·®)</td>
            </tr>
            <tr>
                <td><strong>ç©ºé—´å¤æ‚åº¦</strong></td>
                <td><span class="tag tag-good">O(1)</span> (åŸåœ°å»ºå †)</td>
                <td><span class="tag tag-good">O(1)</span> (è¿­ä»£å†™æ³•) / O(log N) (é€’å½’æ ˆ)</td>
            </tr>
            <tr>
                <td><strong>å†…å­˜è®¿é—®</strong></td>
                <td>
                    <span class="tag tag-bad">è·³è·ƒå¼</span><br>
                    <small>çˆ¶å­èŠ‚ç‚¹ç´¢å¼• index ä¸ 2*index+1 è·ç¦»è¿œï¼Œç¼“å­˜å‘½ä¸­ç‡ä½</small>
                </td>
                <td>
                    <span class="tag tag-good">é¡ºåºå¼</span><br>
                    <small>åŒæŒ‡é’ˆçº¿æ€§æ‰«ææ•°ç»„ï¼ŒCPU ç¼“å­˜æå…¶å‹å¥½</small>
                </td>
            </tr>
            </tbody>
        </table>
    </div>
</div>

<script>
    // --- å…¨å±€å˜é‡ ---
    let mode = 'heap';
    let frames = [];
    let curFrame = 0;
    let isPlaying = false;
    let timer = null;

    // --- å †åæ ‡ç³»ç»Ÿ (å›ºå®šåæ ‡è§£å†³ä¹±é£˜é—®é¢˜) ---
    // é€‚é… 800x400 å®¹å™¨
    const HEAP_POS = [
        {x: 400, y: 50},  // root
        {x: 220, y: 130}, {x: 580, y: 130}, // layer 2
        {x: 130, y: 220}, {x: 310, y: 220}, {x: 490, y: 220}, {x: 670, y: 220}, // layer 3
        {x: 80,  y: 300}, {x: 180, y: 300}, {x: 260, y: 300} // layer 4 demo
    ];

    // ===========================
    // 1. ç®—æ³•é€»è¾‘ç”Ÿæˆå™¨ (Core Logic)
    // ===========================

    // --- Heap Logic ---
    function generateHeapFrames(arr, k) {
        let nums = [...arr];
        let n = nums.length;
        let history = [];

        const snap = (msg, type, active=[], ptrs={}) => {
            history.push({ mode: 'heap', nums: [...nums], size: ptrs.size??n, msg, type, active, ptrs });
        };

        // Heapify Down
        const heapify = (size, i) => {
            let largest = i;
            let l = 2*i + 1, r = 2*i + 2;
            snap(`æ¯”è¾ƒèŠ‚ç‚¹ ${i} ä¸å­èŠ‚ç‚¹`, 'compare', [i, l<size?l:-1, r<size?r:-1], {size, i});

            if (l < size && nums[l] > nums[largest]) largest = l;
            if (r < size && nums[r] > nums[largest]) largest = r;

            if (largest !== i) {
                snap(`äº¤æ¢: ${nums[i]} <-> ${nums[largest]}`, 'swap', [i, largest], {size, i, largest});
                [nums[i], nums[largest]] = [nums[largest], nums[i]];
                heapify(size, largest);
            }
        };

        // 1. Build Heap
        for (let i = Math.floor(n/2)-1; i >= 0; i--) heapify(n, i);
        snap("å¤§é¡¶å †æ„å»ºå®Œæˆ", 'sorted', [0], {size: n});

        // 2. Extract K times
        let currSize = n;
        for (let i = n-1; i >= n - k + 1; i--) { // åªéœ€åš k-1 æ¬¡äº¤æ¢ï¼Œç¬¬ k æ¬¡å †é¡¶å³ç»“æœ
            snap(`äº¤æ¢å †é¡¶ä¸æœ«å°¾ï¼Œç§»é™¤æœ€å¤§å€¼ ${nums[0]}`, 'swap', [0, i], {size: currSize});
            [nums[0], nums[i]] = [nums[i], nums[0]];
            currSize--;
            snap(`ä¿®å¤å †é¡¶ï¼Œå †å¤§å°: ${currSize}`, 'normal', [], {size: currSize});
            heapify(currSize, 0);
        }

        snap(`å †é¡¶ ${nums[0]} å³ä¸ºç¬¬ ${k} å¤§å…ƒç´ `, 'found', [0], {size: currSize});
        return history;
    }

    // --- Quick Select Logic ---
    function generateQuickFrames(arr, k) {
        let nums = [...arr];
        let n = nums.length;
        let target = n - k;
        let history = [];

        const snap = (msg, type, active=[], ptrs={}) => {
            history.push({ mode: 'quick', nums: [...nums], msg, type, active, ptrs });
        };

        let left = 0, right = n - 1;
        while (true) {
            if (left === right) {
                snap(`åŒºé—´ç¼©å°ä¸º1ï¼Œæ‰¾åˆ°ç»“æœ ${nums[left]}`, 'found', [left], {left, right, target});
                break;
            }

            let pivotIdx = left;
            let pivotVal = nums[pivotIdx];
            snap(`åŒºé—´ [${left}, ${right}], Pivot=${pivotVal}`, 'pivot', [pivotIdx], {left, right, target, pivot: pivotIdx});

            // Swap pivot to right
            [nums[pivotIdx], nums[right]] = [nums[right], nums[pivotIdx]];
            snap(`Pivot ç§»è‡³æœ€å³æš‚å­˜`, 'swap', [pivotIdx, right], {left, right, target, pivot: right});

            let store = left;
            for (let i = left; i < right; i++) {
                snap(`æ¯”è¾ƒ ${nums[i]} < Pivot ?`, 'compare', [i, right], {left, right, target, i, store, pivot: right});
                if (nums[i] < pivotVal) {
                    if (i !== store) {
                        [nums[i], nums[store]] = [nums[store], nums[i]];
                        snap(`äº¤æ¢åˆ° store ä½ç½®`, 'swap', [i, store], {left, right, target, i, store, pivot: right});
                    }
                    store++;
                }
            }
            [nums[store], nums[right]] = [nums[right], nums[store]];
            snap(`Pivot å½’ä½`, 'swap', [store, right], {left, right, target, pivot: store});

            if (store === target) {
                snap(`Pivot ä¸‹æ ‡ ${store} ç­‰äºç›®æ ‡ ${target}ï¼Œæ‰¾åˆ°ç»“æœ!`, 'found', [store], {left, right, target, pivot: store});
                break;
            } else if (store < target) {
                snap(`Pivot < Targetï¼Œå‘å³æ‰¾`, 'normal', [], {left: store+1, right, target});
                left = store + 1;
            } else {
                snap(`Pivot > Targetï¼Œå‘å·¦æ‰¾`, 'normal', [], {left, right: store-1, target});
                right = store - 1;
            }
        }
        return history;
    }

    // ===========================
    // 2. æ¸²æŸ“å¼•æ“ (Renderer)
    // ===========================

    function renderFrame(idx) {
        if (!frames[idx]) return;
        const f = frames[idx];
        const stage = document.getElementById('stage-container');
        stage.innerHTML = ''; // æ¸…ç©ºç”»å¸ƒ

        // æ›´æ–°æ§åˆ¶æ¡
        document.getElementById('logTxt').innerText = f.msg;
        document.getElementById('stepTxt').innerText = `${idx+1}/${frames.length}`;
        document.getElementById('progressBar').value = idx;

        if (mode === 'heap') renderHeap(stage, f);
        else renderQuick(stage, f);
    }

    function renderHeap(stage, frame) {
        // 1. ç»˜åˆ¶ SVG è¿çº¿
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("class", "lines-layer");

        frame.nums.forEach((val, i) => {
            if (i >= HEAP_POS.length) return;
            // ç”»çˆ¶èŠ‚ç‚¹è¿çº¿
            if (i > 0) {
                const pIdx = Math.floor((i-1)/2);
                if (pIdx < HEAP_POS.length) {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", HEAP_POS[pIdx].x + 22); // center of node
                    line.setAttribute("y1", HEAP_POS[pIdx].y + 22);
                    line.setAttribute("x2", HEAP_POS[i].x + 22);
                    line.setAttribute("y2", HEAP_POS[i].y + 22);
                    if (i >= frame.size) line.style.opacity = 0.1; // å †å¤–è™šåŒ–
                    svg.appendChild(line);
                }
            }
        });
        stage.appendChild(svg);

        // 2. ç»˜åˆ¶èŠ‚ç‚¹
        frame.nums.forEach((val, i) => {
            if (i >= HEAP_POS.length) return;
            const node = document.createElement('div');
            node.className = 'node-base heap-node';
            node.innerText = val;
            node.style.left = HEAP_POS[i].x + 'px';
            node.style.top = HEAP_POS[i].y + 'px';

            // æ ·å¼å¤„ç†
            if (i >= frame.size) node.classList.add('hl-inactive');
            if (frame.active.includes(i)) {
                if (frame.type === 'compare') node.classList.add('hl-compare');
                if (frame.type === 'swap') node.classList.add('hl-swap');
                if (frame.type === 'found') node.classList.add('hl-sorted');
            }

            // æŒ‡é’ˆ
            if (frame.ptrs.i === i) addPtr(stage, 'i', HEAP_POS[i].x+10, HEAP_POS[i].y-25, 'ptr-i');

            stage.appendChild(node);
        });
    }

    function renderQuick(stage, frame) {
        const row = document.createElement('div');
        row.className = 'quick-row';

        frame.nums.forEach((val, i) => {
            const node = document.createElement('div');
            node.className = 'node-base quick-node';
            node.innerText = val;

            const idxLbl = document.createElement('div');
            idxLbl.className = 'idx-tag';
            idxLbl.innerText = i;
            node.appendChild(idxLbl);

            // çŠ¶æ€
            if (i < frame.ptrs.left || i > frame.ptrs.right) node.classList.add('hl-inactive');
            if (i === frame.ptrs.pivot) node.classList.add('hl-pivot');
            if (i === frame.ptrs.target) node.style.border = '2px dashed blue';

            if (frame.active.includes(i)) {
                if (frame.type === 'compare') node.classList.add('hl-compare');
                if (frame.type === 'swap') node.classList.add('hl-swap');
                if (frame.type === 'found') node.classList.add('hl-sorted');
            }

            // æŒ‡é’ˆ (ç›¸å¯¹å®šä½)
            if (i === frame.ptrs.i) addPtr(node, 'i', 12, -30, 'ptr-i', true);
            if (i === frame.ptrs.store) addPtr(node, 'j', 12, 45, 'ptr-j', true); // quick logic var is sometimes store

            row.appendChild(node);
        });
        stage.appendChild(row);
    }

    function addPtr(parent, txt, x, y, cls, isRelative=false) {
        const p = document.createElement('div');
        p.className = `ptr ${cls}`;
        p.innerText = txt;
        if (isRelative) {
            p.style.top = y + 'px';
            p.style.left = x + 'px';
        } else {
            p.style.left = x + 'px';
            p.style.top = y + 'px';
        }
        parent.appendChild(p);
    }

    // ===========================
    // 3. æ§åˆ¶ä¸äº¤äº’ (Controls)
    // ===========================

    function switchMode(m) {
        mode = m;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`.t-${m}`).classList.add('active');
        init();
    }

    function init() {
        stopPlay();
        const str = document.getElementById('arrIn').value;
        const k = parseInt(document.getElementById('kIn').value);
        let arr = str.split(',').map(n => parseInt(n.trim()));

        if (arr.length > 10) { alert("ä¸ºäº†æ¼”ç¤ºæ•ˆæœï¼Œå»ºè®®æ•°ç»„é•¿åº¦ <= 10"); arr = arr.slice(0,10); }

        frames = (mode === 'heap') ? generateHeapFrames(arr, k) : generateQuickFrames(arr, k);

        document.getElementById('progressBar').max = Math.max(0, frames.length - 1);
        curFrame = 0;
        renderFrame(0);
    }

    function togglePlay() {
        if (isPlaying) stopPlay();
        else {
            isPlaying = true;
            document.getElementById('playBtn').innerText = 'â¸';
            if (curFrame >= frames.length - 1) curFrame = 0;
            const delay = parseInt(document.getElementById('speedSel').value);
            timer = setInterval(() => step(1), delay);
        }
    }

    function stopPlay() {
        isPlaying = false;
        clearInterval(timer);
        document.getElementById('playBtn').innerText = 'â¯';
    }

    function step(d) {
        let next = curFrame + d;
        if (next >= 0 && next < frames.length) {
            curFrame = next;
            renderFrame(curFrame);
        } else {
            stopPlay();
        }
    }

    function seek(v) {
        stopPlay();
        curFrame = parseInt(v);
        renderFrame(curFrame);
    }

    // Init
    window.onload = init;

</script>
</body>
</html>
